{"cells":[{"cell_type":"code","source":"# -*- coding: utf-8 -*-\n\"\"\"\nFile 1: Rule-Based Ground Truth Generation\nApplies the final expert rule-based model (v9) to all flight data\nfiles in the Input_MAT folder to generate the labeled dataset.\n\"\"\"\n\nimport os\nimport pandas as pd\nimport numpy as np\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\n# --- Main Configuration ---\nSOURCE_FOLDER = r'Input_MAT'\nOUTPUT_FOLDER = r'Results/Rule_Based_Results'\nos.makedirs(OUTPUT_FOLDER, exist_ok=True)\n\nREQUIRED_FEATURES = ['ALT', 'RALT', 'ALTR', 'GS']\nTRIM_POINTS = 500\n\n# --- Final Rule-Based Model (v9) Constants ---\nGROUND_RADIO_ALT_THRESHOLD = 400\nVSPEED_CLIMB_THRESHOLD = 500\nVSPEED_DESCENT_THRESHOLD = -500\nCRUISE_ALTITUDE_THRESHOLD = 25000\nLEVEL_MIN_ALTITUDE_THRESHOLD = 1000\nAIRBORNE_SPEED_THRESHOLD = 60\n\n# --- Data Processing and Classification Functions ---\n\ndef load_and_resample_mat_data(file_path, variables):\n    try:\n        mat_data = loadmat(file_path)\n        extracted_data = {}\n        max_length = 0\n        for var_name in variables:\n            try:\n                data_array = mat_data[var_name]['data'][0, 0].ravel()\n                extracted_data[var_name] = data_array\n                if len(data_array) > max_length:\n                    max_length = len(data_array)\n            except (KeyError, IndexError): return None\n        df = pd.DataFrame(index=range(max_length))\n        for var_name, data_array in extracted_data.items():\n            s = pd.Series(data_array)\n            if len(s) < max_length:\n                s = s.reindex(range(max_length)).fillna(method='ffill').fillna(method='bfill')\n            df[var_name] = s\n        for var in variables:\n            if var not in df.columns: df[var] = 0\n        if len(df) > TRIM_POINTS: df = df.iloc[:-TRIM_POINTS]\n        return df.astype(float)\n    except Exception: return None\n\ndef classify_flight_phases_rules_v9(row):\n    alt, ralt, altr, gs = row.get('ALT', 0), row.get('RALT', 0), row.get('ALTR', 0), row.get('GS', 0)\n    if gs == 0: return 'On Stand'\n    if altr > VSPEED_CLIMB_THRESHOLD: return 'Climb'\n    if ralt < GROUND_RADIO_ALT_THRESHOLD: return 'Taxi'\n    if altr < VSPEED_DESCENT_THRESHOLD and ralt > GROUND_RADIO_ALT_THRESHOLD: return 'Descent'\n    if alt > CRUISE_ALTITUDE_THRESHOLD and gs > AIRBORNE_SPEED_THRESHOLD: return 'Cruise'\n    if (LEVEL_MIN_ALTITUDE_THRESHOLD < alt <= CRUISE_ALTITUDE_THRESHOLD) and (gs > AIRBORNE_SPEED_THRESHOLD): return 'Level Flight'\n    return 'Unknown'\n\ndef plot_flight_segmentation(df, flight_name, output_folder):\n    fig, ax = plt.subplots(1, 1, figsize=(20, 8))\n    fig.suptitle(f'Rule-Based Segmentation (v9) for Flight: {flight_name}', fontsize=16)\n    color_map = {'On Stand': 'darkgrey', 'Taxi': 'grey', 'Climb': 'green', 'Cruise': 'blue', 'Descent': 'purple', 'Level Flight': 'cyan'}\n    ax.plot(df.index, df['ALT'], color='black', linewidth=1.5, label='Altitude (MSL)')\n    for phase, color in color_map.items():\n        ax.fill_between(df.index, 0, df['ALT'].max()*1.1, where=(df['Rule_Phase'] == phase), facecolor=color, alpha=0.5, label=phase)\n    ax.set_title('Altitude Profile with Classified Phases')\n    ax.set_xlabel('Time Steps'); ax.set_ylabel('Altitude (ft)')\n    ax.grid(True, linestyle='--'); ax.set_ylim(0, df['ALT'].max() * 1.15)\n    handles, labels = ax.get_legend_handles_labels()\n    by_label = dict(zip(labels, handles))\n    if 'Unknown' in df['Rule_Phase'].unique(): by_label['Unknown'] = plt.Rectangle((0,0),1,1,fc=\"white\", ec=\"black\", lw=0.5)\n    fig.legend(by_label.values(), by_label.keys(), title='Flight Phases', bbox_to_anchor=(1.0, 0.9), loc='upper left')\n    plt.tight_layout(rect=[0, 0, 0.9, 0.96])\n    output_image_path = os.path.join(output_folder, f'rule_based_{flight_name.replace(\".mat\", \"\")}.png')\n    plt.savefig(output_image_path, bbox_inches='tight')\n    plt.close(fig)\n    return output_image_path\n\n# --- Main Execution ---\nif __name__ == \"__main__\":\n    if not os.path.isdir(SOURCE_FOLDER):\n        print(f\"Error: Source folder not found at '{SOURCE_FOLDER}'. Please create it and add the .mat files.\")\n    else:\n        all_mat_files = sorted([f for f in os.listdir(SOURCE_FOLDER) if f.endswith('.mat')])\n        if not all_mat_files:\n            print(f\"Error: No .mat files found in '{SOURCE_FOLDER}'.\")\n        else:\n            print(f\"--- Found {len(all_mat_files)} flights. Starting Ground Truth generation... ---\")\n            all_flights_summary = []\n            for flight_file in all_mat_files:\n                print(f\"\\nProcessing flight: {flight_file}\")\n                flight_path = os.path.join(SOURCE_FOLDER, flight_file)\n                df = load_and_resample_mat_data(flight_path, REQUIRED_FEATURES)\n                if df is not None and not df.empty:\n                    df['Rule_Phase'] = df.apply(classify_flight_phases_rules_v9, axis=1)\n                    phase_distribution = df['Rule_Phase'].value_counts(normalize=True)\n                    summary = phase_distribution.to_dict()\n                    summary['flight_name'] = flight_file\n                    all_flights_summary.append(summary)\n                    plot_path = plot_flight_segmentation(df, flight_file, OUTPUT_FOLDER)\n                    print(f\"  -> Plot saved to: {plot_path}\")\n                else:\n                    print(f\"  -> Warning: Failed to process {flight_file}. Skipping.\")\n            \n            if all_flights_summary:\n                summary_df = pd.DataFrame(all_flights_summary).set_index('flight_name')\n                summary_df = summary_df.fillna(0)\n                ordered_cols = ['On Stand', 'Taxi', 'Climb', 'Level Flight', 'Cruise', 'Descent', 'Unknown']\n                summary_df = summary_df.reindex(columns=[col for col in ordered_cols if col in summary_df.columns])\n                summary_csv_path = os.path.join(OUTPUT_FOLDER, 'ground_truth_summary.csv')\n                summary_df.to_csv(summary_csv_path)\n                print(f\"\\n--- Final summary report saved to: {summary_csv_path} ---\")\n            print(\"\\n--- Ground Truth generation completed successfully! ---\")","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}